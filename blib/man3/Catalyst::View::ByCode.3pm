.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.13)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Catalyst::View::ByCode 3"
.TH Catalyst::View::ByCode 3 "2010-03-28" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Catalyst::View::ByCode \- Templating using pure Perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # 1) use the helper to create your View
\&    myapp_create.pl view ByCode ByCode
\&
\&
\&    # 2) inside your Controllers do business as usual:
\&    sub index :Path :Args(0) {
\&        my ($self, $c) = @_;
\&        
\&        # unless defined as default_view in your config, specify:
\&        $c\->stash\->{current_view} = \*(AqByCode\*(Aq;
\&        
\&        $c\->stash\->{title} = \*(AqHello ByCode\*(Aq;
\&        
\&        # if omitted, would default to 
\&        # controller_namespace / action_namespace .pl
\&        $c\->stash\->{template} = \*(Aqhello.pl\*(Aq;
\&    }
\&
\&
\&    # 3) create a simple template eg \*(Aqroot/bycode/hello.pl
\&    # REMARK: 
\&    #    use \*(Aqc\*(Aq instead of \*(Aq$c\*(Aq
\&    #    prefer \*(Aqstash\->{...}\*(Aq to \*(Aqc\->stash\->{...}\*(Aq
\&    template {
\&        html {
\&            head {
\&                title { stash\->{title} };
\&                load Js => \*(Aqsite.js\*(Aq;
\&                load Css => \*(Aqsite.css\*(Aq;
\&            };
\&            body {
\&                div header.noprint {
\&                    ul.topnav {
\&                        li {\*(Aqhome\*(Aq};
\&                        li {\*(Aqsurprise\*(Aq};
\&                    };
\&                };
\&                div content {
\&                    h1 { stash\->{title} };
\&                    div { \*(Aqhello.pl is running!\*(Aq };
\&                    img(src => \*(Aq/static/images/catalyst_logo.png\*(Aq);
\&                };
\&            };
\&        };
\&    };
\&    # 274 characters without white space
\&    
\&    
\&    # 4) expect to get this HTML generated:
\&    <html>
\&      <head>
\&        <title>Hello ByCode!</title>
\&        <script src="http://localhost:3000/js/site.js" type="text/javascript">
\&        </script>
\&        <link rel="stylesheet" href="http://localhost:3000/css/site.css" type="text/css" />
\&      </head>
\&      <body>
\&        <div id="header" style="noprint">
\&          <ul class="topnav">
\&            <li>home</li>
\&            <li>surprise</li>
\&          </ul>
\&        </div>
\&        <div class="content">
\&          <h1>Hello ByCode!</h1>
\&          <div>hello.pl is running!</div>
\&          <img src="/static/images/catalyst_logo.png" />
\&        </div>
\&      </body>
\&    </html>
\&    # 453 characters without white space
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Catalyst::View::ByCode\*(C'\fR tries to offer an efficient, fast and robust
solution for generating \s-1HTML\s0 and \s-1XHTML\s0 markup using standard perl code
encapsulating all nesting into code blocks.
.PP
Instead of typing opening and closing HTML-Tags we simply call a
sub named like the tag we want to generate:
.PP
.Vb 1
\&    div { \*(Aqhello\*(Aq }
.Ve
.PP
generates:
.PP
.Vb 1
\&    <div>hello</div>
.Ve
.PP
There is no templating language you will have to learn, no quirks with
different syntax rules your editor might not correctly follow and no
indentation problems.
.PP
The whole markup is initially constructed as a huge tree-like
structure in memory keeping every reference as long as possible to
allow greatest flexibility and enable deferred construction of every
building block until the markup is actially requested.
.PP
Every part of the markup can use almost every type of data with some
reasonable behavior during markup generation.
.Sh "Tags"
.IX Subsection "Tags"
Every tag known in \s-1HTML\s0 (or defined in HTML::Tagset to be precise) gets
exported to a template's namespace during its compilation and can be used as
expected. However, there are some exceptions which would collide with \s-1CORE\s0
subs or operators
.IP "choice" 12
.IX Item "choice"
generates a <select> tag
.IP "link_tag" 12
.IX Item "link_tag"
generates a <link> tag
.IP "trow" 12
.IX Item "trow"
generates a <tr> tag
.IP "tcol" 12
.IX Item "tcol"
generates a <td> tag
.IP "subscript" 12
.IX Item "subscript"
generates a <sub> tag
.IP "superscript" 12
.IX Item "superscript"
generates a <sup> tag
.IP "meta_tag" 12
.IX Item "meta_tag"
generates a <meta> tag
.IP "quote" 12
.IX Item "quote"
generates a <q> tag
.IP "strike" 12
.IX Item "strike"
generates a <s<gt> tag
.IP "map_tag" 12
.IX Item "map_tag"
generates a <map> tag
.PP
Internally, every tag subroutine is defined with a prototype like
.PP
.Vb 1
\&    sub div(;&@) { ... }
.Ve
.PP
Thus, the first argument of this sub is expected to be a coderef, which allows
to write code like the examples above. Nesting tags is just a matter of
nesting calls into blocks.
.Sh "Content"
.IX Subsection "Content"
There are several ways to generate content which is inserted between the
opening and the closing tag:
.IP "\(bu" 4
The return value of the last expression of a code block will get appended to
the content inside the tag. The content will get escaped when needed.
.IP "\(bu" 4
To append any content (getting escaped) at any point of the markup generation,
the \f(CW\*(C`OUT\*(C'\fR glob can be used:
.Sp
.Vb 1
\&    print OUT \*(Aqsome content here.\*(Aq;
.Ve
.IP "\(bu" 4
To append unescaped content eg JavaScript or the content of another
markup-generating subsystem like \f(CW\*(C`HTML::FormFu\*(C'\fR simple use the <\s-1RAW\s0> glob:
.Sp
.Vb 1
\&    print RAW \*(Aq<?xxx must be here for internal reasons ?>\*(Aq;
.Ve
.Sh "Attributes"
.IX Subsection "Attributes"
As usual for Perl, there is always more than one way to do it:
.IP "old-school perl" 4
.IX Item "old-school perl"
.Vb 4
\&    # appending attributes after tag
\&    div { ... content ... } id => \*(Aqtop\*(Aq, 
\&                            class => \*(Aqnoprint silver\*(Aq,
\&                            style => \*(Aqdisplay: none\*(Aq;
.Ve
.Sp
the content goes into the curly-braced code block immediately following the
tag. Every extra argument after the code block is converted into the tag's
attributes.
.IP "special content" 4
.IX Item "special content"
.Vb 5
\&    # using special methods
\&    div {
\&        id \*(Aqtop\*(Aq;
\&        class \*(Aqnoprint silver\*(Aq;
\&        attr style => \*(Aqdisplay: none\*(Aq;
\&        
\&        \*(Aqcontent\*(Aq
\&    };
.Ve
.Sp
Every attribute may be added to the latest opened tag using the \f(CW\*(C`attr\*(C'\fR sub. However, there are some shortcuts:
.RS 4
.IP "id 'name'" 8
.IX Item "id 'name'"
is equivalent to \f(CW\*(C`attr id =\*(C'\fR 'name'>
.IP "class 'class'" 8
.IX Item "class 'class'"
is the same as \f(CW\*(C`attr class =\*(C'\fR 'class'>
.Sp
However, the \f(CW\*(C`class\*(C'\fR method is special. It allows to specify a
space-separated string, a list of names or a combination of both. Class names
prefixed with \f(CW\*(C`\-\*(C'\fR or \f(CW\*(C`+\*(C'\fR are treated special. After a minus prefixed class
name every following name is subtracted from the previous list of class names.
After a plus prefixed name all following names are added to the class list. A
list of class names without a plus/minus prefix will start with an empty class
list and then append all subsequentially following names.
.Sp
.Vb 3
\&    div.foo { class \*(Aqabc def ghi\*(Aq };             will yield \*(Aqabc def ghi\*(Aq
\&    div.foo { class \*(Aq+def xyz\*(Aq };                will yield \*(Aqfoo def xyz\*(Aq
\&    div.foo { class \*(Aq\-foo +bar\*(Aq };               will yield \*(Aqbar\*(Aq
.Ve
.IP "on handler => 'some javascript code'" 8
.IX Item "on handler => 'some javascript code'"
produces the same result as \f(CW\*(C`attr onhandler =\*(C'\fR 'some javascript code'>
.Sp
.Vb 3
\&    div {
\&        on click => q{alert(\*(Aqyou clicked me\*(Aq)};
\&    };
.Ve
.RE
.RS 4
.RE
.IP "tricky arguments" 4
.IX Item "tricky arguments"
.Vb 1
\&    div top.noprint.silver(style => \*(Aqdisplay: none\*(Aq) {\*(Aqcontent\*(Aq};
.Ve
.IP "even more tricky arguments" 4
.IX Item "even more tricky arguments"
.Vb 1
\&    div top.noprint.silver(style => {display => \*(Aqnone\*(Aq}) {\*(Aqcontent\*(Aq};
.Ve
.IP "tricky arguments and CamelCase" 4
.IX Item "tricky arguments and CamelCase"
.Vb 1
\&    div top.noprint.silver(style => {marginTop => \*(Aq20px\*(Aq}) {\*(Aqcontent\*(Aq};
.Ve
.Sp
\&\f(CW\*(C`marginTop\*(C'\fR or \f(CW\*(C`margin_top\*(C'\fR will get converted to \f(CW\*(C`margin\-top\*(C'\fR.
.PP
Every attribute may have almost any datatype you might think of:
.IP "scalar" 4
.IX Item "scalar"
Scalar values are taken verbatim.
.IP "hashref" 4
.IX Item "hashref"
Hash references are converted to semicolon-delimited pairs of the key, a colon
and a value. The perfect solution for building inline \s-1CSS\s0. Well, I know,
nobody should do something, but sometimes...
.Sp
Keys consisting of underscore characters and \s-1CAPITAL\s0 letters are converted to
dash-separated names. \f(CW\*(C`dataTarget\*(C'\fR or \f(CW\*(C`data_target\*(C'\fR both become \f(CW\*(C`data\-target\*(C'\fR.
.IP "arrayref" 4
.IX Item "arrayref"
Array references are converted to space separated things.
.IP "coderef \*(-- \s-1FIXME:\s0 do we like this?" 4
.IX Item "coderef  FIXME: do we like this?"
no idea if we like this
.IP "other refs" 4
.IX Item "other refs"
all other references simply are stringified. This allows the various objects
to forward stringification to their class-defined code.
.Sh "Special Methods"
.IX Subsection "Special Methods"
.IP "doctype" 4
.IX Item "doctype"
.PD 0
.IP "load" 4
.IX Item "load"
.PD
.Sh "Building Reusable blocks"
.IX Subsection "Building Reusable blocks"
You might build a reusable block line the following calls:
.PP
.Vb 1
\&    block \*(Aqblock_name\*(Aq => sub { ... };
\&    
\&    # or shorter:
\&    block block_name { ... };
.Ve
.PP
The block might get used like a tag:
.PP
.Vb 1
\&    block_name { ... some content ... };
.Ve
.PP
If a block-call contains a content it can get rendered inside the block using
the special sub \f(CW\*(C`block_content\*(C'\fR. A simple example makes this clearer:
.PP
.Vb 8
\&    # define a block:
\&    block infobox {
\&        my $headline = attr(\*(Aqheadline\*(Aq) || \*(Aquntitled\*(Aq;
\&        my $id = attr(\*(Aqid\*(Aq);
\&        my $class = attr(\*(Aqclass\*(Aq);
\&        div.infobox {
\&            id $id if ($id);
\&            class $class if ($class);
\&            
\&            div.head { $headline };
\&            div.info { block_content };
\&        };
\&    };
\&    
\&    # later we use the block:
\&    infobox some_id.someclass(headline => \*(AqOur Info\*(Aq) { \*(Aqjust my 2 cents\*(Aq };
\&    
\&    # this HTML will get generated:
\&    <div class="someclass" id="some_id">
\&      <div class="head">Our Info</div>
\&      <div class="info">just my 2 cents</div>
\&    </div>
.Ve
.PP
every block defined in a package is auto-added to the packages \f(CW@EXPORT\fR
array and mangled in a special way to make the magic calling syntax work after
importing it into another package.
.SH "CONFIGURATION"
.IX Header "CONFIGURATION"
A simple configuration of a derived Controller could look like this:
.PP
.Vb 3
\&    _\|_PACKAGE_\|_\->config(
\&        # Change extension (default: .pl)
\&        extension => \*(Aq.pl\*(Aq,
\&        
\&        # Set the location for .pl files (default: root/bycode)
\&        root_dir => cat_app\->path_to( \*(Aqroot\*(Aq, \*(Aqbycode\*(Aq ),
\&        
\&        # This is your wrapper template located in root_dir (default: wrapper.pl)
\&        wrapper => \*(Aqwrapper.pl\*(Aq,
\&        
\&        # all these modules are use()\*(Aqd automatically
\&        include => [Some::Module Another::Package],
\&    );
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "process"
.IX Subsection "process"
fulfill the request (called from Catalyst)
.SH "AUTHOR"
.IX Header "AUTHOR"
Wolfgang Kinkeldei, <wolfgang@kinkeldei.de>
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software, you can redistribute it and/or modify
it under the same terms as Perl itself.
